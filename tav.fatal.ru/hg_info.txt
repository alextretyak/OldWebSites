UNCATEGORIZED INFO:
При коммитах рекомендуется всегда писать сообщение. В крайнем случае можно обойтись краткими: bugfix, fix, new feature, refactor, redesign, comment, clean up, feature in progress.

В отличие от SVN в Mercurial в случае когда два человека делают одинаковые изменения в одном файле, конфликта не возникает.

tip - последняя закоммиченная ревизия.
head - последняя ревизия (голова) бранча.
commit всегда успешен.
:END

Команда Mercurial (название в TortoiseHG) - Аналог в SVN - Описание:
hg revert (Undo changes) - Revert... - Отменить изменения в рабочей папке, приведя их т.о. к состоянию из текущей ревизии (напр. так можно отменить изменения в файле до его коммита;  после коммита можно отменить изменения по hg rollback (Recovery...->Rollback))
hg update -C (Overwrite local changes) - Revert to revision - Заменить файлы рабочей папки файлами из выбранной ревизии, т.о. после выполнения операции их можно закоммитить
hg update (Update to revision) - Update to revision - Сделать апдейт до указанной ревизии, аналогично предыдущей операции, но закоммитить файлы нельзя, т.к. тек. ревизия ставится в заданную (в пред. случае она не менялась, и коммит изменений создаст новый бранч, исходящий из тек. ревизии)
hg backout (View Changelog -> backout revision) - Revert changes from revision - Аннулировать изменения сделанные в определенной (и только одной) ревизии
hg annotate/hg blame (Annotate Files) - Blame... - Позволяет узнать кто и когда менял любую строку в файле

Команды управления историей:
hg strip (View Changelog -> strip revision) - удаляет выбранную ревизию и всех её потомков, создает backup-патч, который позволяет отменить удаление.
hg rollback (Recovery -> Rollback) - откат последней операции (полезно когда напр. были стянуты изменения с сервера, которые ломают билд, или когда нужно отменить локальный коммит)
hg rebase (см. ниже)
Однако, следует учесть что из-за распределенной архитектуры Mercurial, удалённая история, которая присутствует в одной из копий репозитория, будет "восстановлена" при работе с этим репозиторием, т.о. если напр. был сделан rollback push-а на сервер, то и на самом сервере надо сделать rollback pull-а, и если кто-то успел взять эти изменения с сервера, rollback нужно сделать у него. Но в случае, когда кто-то успел залить новые изменения на сервер, операцию rollback делать нельзя, т.к. отменятся чужие изменения (однако т.к. они остались у того, кто их внёс, при следующем push-е он их опять зальет на сервер).

Workflow (Рабочий процесс)
Вся работа с Mercurial тесно связана с его системой бранчинга. Каждый коммит создает новый head (последняя ревизия бранча). Если у тек. ревизии уже есть потомок, то коммит приведет к созданию нового бранча, исходящего из текущей ревизии. Чтобы объединить изменения из обоих бранчей, необходимо воспользоваться командой hg merge (Merge Revisions).
Если два человека склонировали репозиторий с сервера, затем каждый сделал какие-то изменения и закоммитил их, тогда первый может безболезненно залить изменения на сервер (hg push), а второму нужно будет сначала взять изменения с сервера (hg pull). Это приведет к созданию нового бранча, исходящего из ревизии, которая была склонирована, этот бранч необходимо смержить с основным, после чего закоммитить, и только после этого можно заливать изменения на сервер. Графически изобразить это можно так (0 - базовая ревизия на сервере, 1 - ревизия с изменениями одного, 2 - с изменениями второго, 3 - итоговая смерженная ревизия)
3_
| \
1 2
|_/
0
В принципе можно обойтись и без мержа бранчей, если работать "в стиле SVN", т.е. для сохранения изменений не делать локальных коммитов, а сначала получить изменения с сервера (они автоматом смержатся с локальными изменениями), затем сделать коммит и тут же залить изменения на сервер, но при таком стиле работы теряется большинство преимуществ распределенных систем контроля версий. Есть еще один вариант - использовать команду hg rebase из одноименного расширения Mercurial, которая позволяет "выпрямить" граф ревизий после получения изменений с сервера, приведших к созданию бранча, т.о. все будет выглядеть так, как будто изменения вносились последовательно, кроме того, команда может одновременно с выпрямлением графа объединить локальные изменения в одно, но к сожалению это расширение доступно только из командной строки.

Плюсом Mercurial является возможность частых коммитов. Если SVN вынуждает не коммитить изменения, которые нежелательны для других (напр. не доделанная/не до конца оттестированная фича/полуфича), т.к. вся работа идет через центральный репозиторий, то Mercurial позволяет задачу, разбитую на этапы, коммитить по частям и уже когда задача полностью реализована можно делать push на сервер. Частые (но не слишком!) коммиты превосходно сочетаются с хорошими практиками использования систем контроля версий, такими как ревью каждого коммита и написание ясных сообщений, поясняющих сделанные изменения.
Также частые коммиты полезны при рефакторинге - можно выделить рефактор в отдельный коммит (закоммитив изменения сразу перед и после него), чтобы автоматически произведенные замены в коде не путались с другими изменениями.

Нужно всегда смотреть на сообщения Mercurial после выполнения операции. При получении изменений с сервера, которые создают новые head-ы, в логе будет написано, что их нужно смержить и обновление до последней версии (если стоит галочка Update to tip) не выполнится автоматически.

Заливка своих изменений на сервер, приводящая к созданию нового бранча (и как следствие head-а) невозможна, поэтому серверу не нужно уметь мержить - мерж делается только у клиентов, т.о. легко поддерживать несколько серверов и синхронизировать их между собой. А чтобы залить такие изменения нужно сначала взять изменения с сервера, это приведет к созданию бранча, затем можно заливать изменения,но обычно делать этого не следует! - сначало нужно сделать merge, commit и только потом заливать на сервер.

В случае если версия в рабочей папке не последняя (tip), то коммит автоматически создает новый бранч, который необходимо явно смержить с tip. (В SVN коммитить изменения с не последней версии (т.е. после update to revision) в принципе не возможно! сначала надо сделать update)

Если в процессе выполнения длительной задачи (на несколько недель напр.) необходимо срочно исправить баг, при этом изменения, относящиеся к этой задаче, нельзя заливать на сервер, то можно воспользоваться следующей последовательностью операций:
1. Выполняется коммит всех текущих изменений в локальный репозиторий (если файл не закоммичен update to revision делать нельзя).
2. Берется номер текущей ревизии на сервере.
3. Апдейт на этот номер ревизии (Update To Revision).
4. Внесение изменений по правке бага.
5. Коммит этих изменений.
6. Push на сервер с Advanced Options - Target Revision: tip. (если не задать tip, то будет попытка залить на сервер все бранчи (которая все-равно провалится без мержа бранчей), а нужно заливать только tip)
7. Merge Revisions: head1(tip) и head2.

Если исправление бага требовало небольших изменении, а также если изменения, касающиеся новой фичи, еще не были закоммичены, можно закоммитить только те изменения, которые касаются исправления бага посредством пункта Select changes в контекстном меню файлов при коммите (в версии 0.7 нужно включить Show Diff и дважды кликнуть на изменениях, которые коммитить не нужно). Также в версии 0.7 появился пункт меню Shelve Changes, с помощью которого можно переместить изменения на "полку", на время "вытащив" их из выбранного файла; изменения можно вернуть обратно с помощью кнопки Unshelve.