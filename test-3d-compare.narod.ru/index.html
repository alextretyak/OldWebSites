<!-- http://test-3d-compare.narod.ru -->
<HTML>
 <HEAD>
  <TITLE>3D-COMPARE</TITLE>
 <HEAD>


 <BODY text="#000000" bgcolor="#ECFCFF">

  <P align="center">
  <IMG src="./pictures/logo.jpg" alt="3D-COMPARE logotype">
  </P>

  <BR>
  <H1 align="center">Введение</H1>
  <P align="justify">Очень часто на форумах по программированию 3D-графики возникают вопросы по поводу "что быстрее" да "как лучше".<BR>
К примеру, кто-то говорит, что лучше вершины для всей статичной геометрии хранить в одном
буфере, кто-то, наоборот, что лучше не пихать всё в одну кучу, а разделить на несколько.<BR>
Да и вообще, очень часто многие принимают на веру алгоритмы и методы, сами не тестируя их и не сравнивая.
Ну, к примеру, всем очевидно, что хранение данных в видеопамяти гораздо быстрее, чем в оперативной.
В данном случае, что-то выяснять действительно нет смысла -- и так всё понятно, но есть и более неоднозначные случаи.<BR>
Как раз для таких случаев я и решил создать серию тестов 3D-COMPARE. Чтобы понять что чучше, в каком/каких случаях и
самое главное, о чём очень часто забывают, какой выигрышь в производительности можно получить при использовании того
или иного метода. И в последнем случае важна не столько производительность, сколько соотношение качество(стабильность)/скорость.
И если есть возможность увеличить FPS, скажем на 30%, но это приведёт к большому усложнению кода, снижению его
понимаемости в несколько раз и, как следствие, надёжности (человеческий фактор ещё никто не отменял), то лучше
обойтись без этой оптимизации. Хотя всё зависит от ситуации.</P>
  <BR>


  <H1 align="center">Тесты</H1>

  <IMG src="./pictures/test1.jpg" alt="Test1 ScreenShot" align="right">

  Итак, представляю вашему вниманию первый тест серии -- 
<A HREF="./download/3Dcmp.test1_geometry_VBOandTextureBinding_r2.rar">geometry.VBOandTextureBinding_r2</A> (984 Кб)<BR>
  Старая версия -- 
<A HREF="./download/3Dcmp.test1_geometry_VBOandTextureBinding.rar">geometry.VBOandTextureBinding</A> (1,13 Мб)<BR>
  Обновление старой версии до r2 -- <A HREF="./download/3Dcmp.test1_geometry_VBOandTextureBinding.Update_to_r2.rar">
geometry.VBOandTextureBinding.Update_to_r2</A> (266 Кб)<BR>
<BR>
<ul type="square">
<li>Назначение теста: определение эффективности использования VBO и сортировки по текстурам.
<li>Геометрическая сложность сцены:
<ul type="disc">
<li>треугольников: 22670;
<li>объектов: 113;
<li>текстур: 10.
</ul>
<li>Число подтестов: 7.
<li>Продолжительность:
<ul type="disc">
<li>холостой ход: 50,9 сек.;
<li>каждый подтест: 46,7667 сек.;
<li>итого: 6 мин. 18,2669 сек. (всего 378,2669 сек.).
</ul>
</ul>
<!-- BR -->
<P align="justify">
Немного о тесте.<BR>
Вначале, как обычно, "разогревочный цикл". Хотя... "как обычно" тут не уместно, т.к. этот тест
первый. Ну ладно. Потом 7 подтестов!!!, циклически замкнутых. Вобщем запускаете и идёте пить кофе.
Я сам с трудом вытерпел 6 минут работы теста. :-)<BR>
В каждом подтесте отображается одно и то же, только разными способами.<BR>
Сцена конечно неудачная, даже слишком. Хуже просто придумать нельзя. Тест предназначен для сравнения
способов вывода статичной геометрии, а всё время сжирает огромный overdraw (готов поспорить больше
вы никогда не видели).<BR>
И чтобы его как-то убавить, тест проходит в разрешении 640x480. Также дополнительную нагрузку на
процессор осуществляет фоновая музыка (хотя там нагрузка просто смешная).<BR>
Но если учесть, что бОльшая часть геометрии не видна, то overdraw более-менее всё это компенсирует.<BR>
<BR>
Теперь о подтестах:<BR>
Первые 4 теста используют VBO (как для вершин, так и для треугольников).<BR>
Во втором тесте используется glInterleavedArrays. (В спецификации OpenGL говорилось, что использование
этой команды вместо нескольких gl*Pointer в некоторых реализациях будет быстрее.)<BR>
Сортировка по текстурам означает, что glBindTexture будет вызываться за кадр столько раз, сколько разных
текстур вообще есть в сцене (т.е. 10), отсутсвие этой сортировки означает, что glBindTexture будет вызываться
столько раз, сколько объектов вообще в сцене (т.е. 133).<BR>
Последний тест вообще беспрецедентно тормозной, т.к. помимо вызова glBegin/glEnd на каждый треугольник
вызывается ещё и glBindTexture.</P>
<!-- BR -->
<BR>
<HR>
18.02.2005<BR>
<BR>
  <IMG src="./pictures/test2.jpg" alt="Test2 ScreenShot" align="right">
  Второй тест серии -- 
<A HREF="./download/3Dcmp.test2_billboards_PointSpritesAndVertexShaders.rar">billboards.PointSpritesAndVertexShaders</A> (653 Кб)<BR>
<A HREF="./download/3Dcmp.test2_billboards_PointSpritesAndVertexShaders.Update_to_r2.1.rar">
Обновление первой версии до r2.1</A> (184 Кб)<BR>
<BR>
<ul type="square">
<li>Назначение теста: определение эффективности использования вершинных шейдеров и PointSprite'ов.
<li>Геометрическая сложность сцены:
<ul type="disc">
<li>треугольников в ландшафте:
<ul type="circle">
<li>всего: 131072;
<li>в стрипах: 151552;
<li>среднее число за кадр (в стрипах): 9173 ± 2;
</ul>
<li>число блоков стрипов: 1024;
<li>частиц (снежинок): 1000000;
<li>текстур: 2.
</ul>
<li>Число подтестов: 5.
<li>Продолжительность:
<ul type="disc">
<li>холостой ход: 9,5 сек.;
<li>каждый подтест: 34,5 сек.;
<li>итого: 3 мин. 2 сек. (всего 182 сек.);
</ul>
<li>Средняя скорость камеры: 26.46 м/с.
<li>Максимальная скорость камеры: 181 м/с.
<li>Системные требования:
<ul type="disc">
<li>процессор: P-II;
<li>ОЗУ: 256 Мб;
<li>VideoRAM: 256 Мб.
</ul>
<li>Вершинные шейдеры:
<ul type="disc">
<li>point.vs - для Points и PointSprite'ов (GL_POINTS);
<li>billboard - для билбордов (GL_QUADS).
</ul>
</ul>
<!-- BR -->
<P align="justify">
Немного о тесте.<BR>
Хоть зима уже кончается, Новый Год давно прошёл, сделал всё-таки тест на зимнюю тему.<BR>
Ну, предмет тестирования, как можно догадаться, снежинки, т.е. скорость их вывода. Я специально не стал придумывать
хитрых алгоритмов для определения их видимости -- весь падающий снег рендерится сразу (причём во всех тестах, кроме одного,
делается это вызовом одной команды glDrawArrays). Таким образом бОльшая часть снежинок не видна и вершинные конвейеры
задействуются по максимуму.<BR>
К слову о снежинках. Помнится на форуме кто-то думал делать 100 штук. Ну, я поначалу тоже думал делать 100 ... тысяч.
А потом решил, что мало. И увеличил это число на порядок. Я бы увеличил и дальше, но мой аппетит умерил тот факт, что
миллион снежинок занимает уже 88 Мб, понятное дело в видеопамяти, так что дальнейшее увеличение неразумно.<BR>
Кстати. О шейдерах. Как обычно у меня бывает, между теорией и практикой большая пропасть (временная), так что хоть и
изучать шейдеры я начал достаточно давно, те, что используются в этом тесте для меня первые, и писать я их начал пару недель назад.
Так что на оптимальность не претендую. А потому их можно свободно изменять самостоятельно. Буду рад предложениям по увеличению
эффективности. К тому же 1-й подтест использует 1-й шейдер, а второй -- 2-й, так что любой сможет быстро определить прирост
скорости от своей оптимизации.<BR>
<BR>
Информация о рендеринге:<BR>
Снежинки для GL_POINTS хранятся в виде трёх float-значений (x,y,shift). Последнее принимает значение от 0 до 1 и соответсвует положению
снежинки в начальный момент времени. 0 -- небо, 1 -- земля. Таким образом z-координата в видовой СК увеличивается со временем.<BR>
Для GL_QUADS каждая снежинка состоит из четырёх вершин. Каждая вершина представляет собой совокупность текстурной координаты
и тройки (x,y,shift), значение которой описано выше.<BR>
<BR>
Замечание: шейдеру "point.vs" предшествует объявление "const float PointSizeC=...;". Значение константы рассчитывается при запуске теста,
после чего формируется окончательный код шейдера (заданием нескольких исходных строк в glShaderSourceARB).</P>

<P align="right">(C) Третьяк А.В.

 </BODY>
</HTML>